[
    {
        "endpoint": "car-battery",
        "query": {
            "id": "teslamate-usable-battery-level",
            "query": "WITH aux AS (SELECT COALESCE(derived_efficiency,car_efficiency) AS efficiency,car_id FROM (SELECT ROUND((charge_energy_added/NULLIF(end_rated_range_km-start_rated_range_km,0))::numeric,3)*100 AS derived_efficiency,COUNT(*) AS count,cars.id AS car_id,cars.efficiency*100 AS car_efficiency FROM cars LEFT JOIN charging_processes ON cars.id=charging_processes.car_id AND duration_min>10 AND end_battery_level<=95 AND start_rated_range_km IS NOT NULL AND end_rated_range_km IS NOT NULL AND charge_energy_added>0 WHERE cars.id=1 GROUP BY 1,3,4 ORDER BY 2 DESC LIMIT 1) AS e), CurrentCapacity AS (SELECT AVG(capacity) AS capacity FROM (SELECT c.rated_battery_range_km*aux.efficiency/c.usable_battery_level AS capacity FROM charging_processes cp INNER JOIN charges c ON c.charging_process_id=cp.id INNER JOIN aux ON cp.car_id=aux.car_id WHERE cp.car_id=1 AND cp.end_date IS NOT NULL AND cp.charge_energy_added>=aux.efficiency AND c.usable_battery_level>0 ORDER BY cp.end_date DESC,c.date DESC LIMIT 100) AS x), last_battery AS (SELECT usable_battery_level,date FROM ((SELECT usable_battery_level,date FROM positions WHERE car_id=1 AND usable_battery_level IS NOT NULL ORDER BY date DESC LIMIT 1) UNION ALL (SELECT c.usable_battery_level,c.date FROM charges c JOIN charging_processes p ON p.id=c.charging_process_id WHERE p.car_id=1 AND c.usable_battery_level IS NOT NULL ORDER BY c.date DESC LIMIT 1)) AS y ORDER BY date DESC LIMIT 1), Lifetime AS (SELECT (SUM(start_rated_range_km-end_rated_range_km) * ((SELECT cars.efficiency*10 FROM cars WHERE id=1)) / SUM(distance))::numeric AS wh_per_km FROM drives WHERE car_id=1 AND distance>0 AND (start_rated_range_km-end_rated_range_km)>0.1) SELECT lb.usable_battery_level AS usable_battery_percentage,(lb.usable_battery_level*COALESCE(cc.capacity,1)/100)::numeric AS usable_battery_kwh,ROUND(((lb.usable_battery_level*COALESCE(cc.capacity,1)/100)::numeric * 10 / Lifetime.wh_per_km),1) AS usable_battery_km FROM last_battery lb CROSS JOIN CurrentCapacity cc CROSS JOIN Lifetime;"
        }
    },
    {
        "endpoint": "car-last-charge",
        "query": {
            "id": "teslamate-last-charge-info",
            "query": "WITH data AS (SELECT start_date,end_date,COALESCE(g.name,CONCAT_WS(', ',COALESCE(addresses.name,nullif(CONCAT_WS(' ',addresses.road,addresses.house_number),'')),addresses.city)) AS location,CASE WHEN NULLIF(mode() within group (order by charger_phases),0) IS NULL THEN 'DC' ELSE 'AC' END AS type,cp.charge_energy_added AS energy_added,start_battery_level AS start_percent,end_battery_level AS end_percent FROM charging_processes cp LEFT JOIN charges c ON cp.id=c.charging_process_id LEFT JOIN positions p ON p.id=cp.position_id LEFT JOIN addresses ON addresses.id=cp.address_id LEFT JOIN geofences g ON g.id=geofence_id WHERE cp.car_id=1 AND (cp.charge_energy_added IS NULL OR cp.charge_energy_added>0) GROUP BY cp.id,p.id,g.id,addresses.id ORDER BY start_date DESC) SELECT start_date AS date,location,type,energy_added,start_percent,end_percent FROM data LIMIT 1;"
        }
    },
    {
        "endpoint": "car-last-location",
        "query": {
            "id": "teslamate-last-seen-location",
            "query": "SELECT COALESCE(a.city, a.neighbourhood, '') AS city, COALESCE(g.name, array_to_string(((string_to_array(a.display_name, ', ', ''))[0:2]), ', ')) AS address, l.end_date AS \"time\" FROM (SELECT address_id, geofence_id, start_date AS end_date FROM charging_processes WHERE car_id = 1 AND end_date IS NOT NULL UNION SELECT end_address_id AS address_id, end_geofence_id AS geofence_id, end_date FROM drives WHERE car_id = 1 AND end_date IS NOT NULL) l INNER JOIN addresses a ON l.address_id = a.id LEFT JOIN geofences g ON l.geofence_id = g.id ORDER BY l.end_date DESC LIMIT 1;"
        }
    },
    {
        "endpoint": "car-state",
        "query": {
            "id": "teslamate-car-state",
            "query": "SELECT state,ts AS since FROM (SELECT end_date AS ts,'driving'::text AS state FROM drives WHERE car_id=1 AND end_date IS NOT NULL UNION ALL SELECT end_date AS ts,'charging'::text AS state FROM charging_processes WHERE car_id=1 AND end_date IS NOT NULL UNION ALL SELECT end_date AS ts,'updating'::text AS state FROM updates WHERE car_id=1 AND end_date IS NOT NULL UNION ALL SELECT start_date AS ts,state::text AS state FROM states WHERE car_id=1) AS all_events ORDER BY ts DESC LIMIT 1;"
        }
    },
    {
        "endpoint": "car-efficiency",
        "query": {
            "id": "teslamate-car-efficiency",
            "query": "WITH Aux AS (SELECT COALESCE(AVG((c.rated_battery_range_km*(cars.efficiency*100)/c.usable_battery_level))::numeric,1) AS usable_kwh FROM charging_processes cp JOIN charges c ON c.charging_process_id=cp.id JOIN cars ON cars.id=cp.car_id WHERE cp.car_id=1 AND cp.end_date IS NOT NULL AND cp.charge_energy_added>=cars.efficiency*100 AND c.usable_battery_level>0), RatedWh AS (SELECT (cars.efficiency*10)::numeric AS rated_wh_per_km FROM cars WHERE id=1), Lifetime AS (SELECT (SUM(start_rated_range_km-end_rated_range_km)*(SELECT rated_wh_per_km FROM RatedWh)/SUM(distance))::numeric AS wh_per_km FROM drives WHERE car_id=1 AND distance>0 AND (start_rated_range_km-end_rated_range_km)>0.1), Eff AS (SELECT ROUND(((SUM(distance)/SUM(start_rated_range_km-end_rated_range_km))*100)::numeric,1) AS driving_efficiency_pct FROM drives WHERE car_id=1 AND distance>0 AND (start_rated_range_km-end_rated_range_km)>0.1) SELECT Eff.driving_efficiency_pct, ROUND(Lifetime.wh_per_km*100,1) AS wh_per_km, ROUND(Aux.usable_kwh,2) AS usable_kwh, ROUND((Aux.usable_kwh*10)/Lifetime.wh_per_km,1) AS real_world_range_km FROM Lifetime,Aux,Eff;"
        }
    },
    {
        "endpoint": "car-drives-history",
        "query": {
            "id": "teslamate-car-drives-info",
            "query": "WITH data AS (SELECT round(extract(epoch FROM start_date)) * 1000 AS start_date_ts, round(extract(epoch FROM end_date)) * 1000 AS end_date_ts, car.id AS car_id, CASE WHEN start_geofence.id IS NULL THEN CONCAT('new?lat=', start_position.latitude, '&lng=', start_position.longitude) ELSE CONCAT(start_geofence.id, '/edit') END AS start_path, CASE WHEN end_geofence.id IS NULL THEN CONCAT('new?lat=', end_position.latitude, '&lng=', end_position.longitude) ELSE CONCAT(end_geofence.id, '/edit') END AS end_path, TO_CHAR((duration_min * INTERVAL '1 minute'), 'HH24:MI') AS duration_str, drives.id AS drive_id, start_date, COALESCE(start_geofence.name, CONCAT_WS(', ', COALESCE(start_address.name, NULLIF(CONCAT_WS(' ', start_address.road, start_address.house_number), '')), start_address.city)) AS start_address, COALESCE(end_geofence.name, CONCAT_WS(', ', COALESCE(end_address.name, NULLIF(CONCAT_WS(' ', end_address.road, end_address.house_number), '')), end_address.city)) AS end_address, duration_min, distance, start_position.usable_battery_level AS start_usable_battery_level, start_position.battery_level AS start_battery_level, end_position.usable_battery_level AS end_usable_battery_level, end_position.battery_level AS end_battery_level, CASE WHEN (start_position.battery_level != start_position.usable_battery_level OR end_position.battery_level != end_position.usable_battery_level) THEN true ELSE false END AS reduced_range, duration_min > 1 AND distance > 1 AND (start_position.usable_battery_level IS NULL OR end_position.usable_battery_level IS NULL OR (end_position.battery_level - end_position.usable_battery_level) = 0) AS is_sufficiently_precise, NULLIF(GREATEST(start_rated_range_km - end_rated_range_km, 0), 0) AS range_diff, car.efficiency AS car_efficiency, outside_temp_avg, distance / COALESCE(NULLIF(duration_min, 0) * 60, extract(epoch FROM end_date - start_date)) * 3600 AS avg_speed, speed_max, power_max FROM drives LEFT JOIN addresses start_address ON start_address_id = start_address.id LEFT JOIN addresses end_address ON end_address_id = end_address.id LEFT JOIN positions start_position ON start_position_id = start_position.id LEFT JOIN positions end_position ON end_position_id = end_position.id LEFT JOIN geofences start_geofence ON start_geofence_id = start_geofence.id LEFT JOIN geofences end_geofence ON end_geofence_id = end_geofence.id LEFT JOIN cars car ON car.id = drives.car_id ORDER BY start_date DESC) SELECT start_date_ts, end_date_ts, car_id, start_path, end_path, duration_str, drive_id, start_date, start_address, end_address, duration_min, convert_km(distance::numeric, 'km') AS distance_km, start_battery_level AS \"% Start\", end_battery_level AS \"% End\", convert_celsius(outside_temp_avg, 'C') AS outside_temp_c, convert_km(avg_speed::numeric, 'km') AS speed_avg_km, convert_km(speed_max::numeric, 'km') AS speed_max_km, power_max, reduced_range AS has_reduced_range, CASE WHEN is_sufficiently_precise THEN distance / range_diff ELSE NULL END AS efficiency, range_diff * car_efficiency AS consumption_kWh, CASE WHEN is_sufficiently_precise THEN range_diff * car_efficiency / convert_km(distance::numeric, 'km') * 1000 END AS consumption_kWh_km FROM data ORDER BY start_date DESC LIMIT {{ number_of_drives }};"
        }
    }
]
